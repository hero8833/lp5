1-A
#include<iostream>
#include<stdlib.h>
#include<queue>
using namespace std;
class node
{
 public:

 node *left, *right;
 int data;
};
class Breadthfs
{

public:

node *insert(node *, int);
void bfs(node *);

};
node *insert(node *root, int data)
// inserts a node in tree
{
 if(!root)
 {

 root=new node;
 root->left=NULL;
 root->right=NULL;
 root->data=data;
 return root;
 }
 queue<node *> q;
 q.push(root);

 while(!q.empty())
 {
 node *temp=q.front();
 q.pop();

 if(temp->left==NULL)
 {

 temp->left=new node;
 temp->left->left=NULL;
 temp->left->right=NULL;
 temp->left->data=data;
 return root;
 }
 else
 {
 q.push(temp->left);
 }
 if(temp->right==NULL)
 {

 temp->right=new node;
 temp->right->left=NULL;
 temp->right->right=NULL;
 temp->right->data=data;
 return root;
 }
 else
 {
 q.push(temp->right);
 }
 }

}
void bfs(node *head)
{
 queue<node*> q;
 q.push(head);

 int qSize;

 while (!q.empty())
 {
 qSize = q.size();
 #pragma omp parallel for
 //creates parallel threads
 for (int i = 0; i < qSize; i++)
 {
 node* currNode;
 #pragma omp critical
 {
 currNode = q.front();
 q.pop();
 cout<<"\t"<<currNode->data;

 }// prints parent node
 #pragma omp critical
 {
 if(currNode->left)// push parent's left node in queue
 q.push(currNode->left);
 if(currNode->right)
 q.push(currNode->right);
 }// push parent's right node in queue
 }
 }
}
int main(){
 node *root=NULL;
 int data;
 char ans;

 do
 {
 cout<<"\n enter data=>";
 cin>>data;

 root=insert(root,data);

 cout<<"do you want insert one more node?";
 cin>>ans;

 }while(ans=='y'||ans=='Y');

 bfs(root);

 return 0;
}

Output- 
3
y
5
y
9
y
6
n



1-B
#include <iostream>
#include <vector>
#include <stack>
#include <omp.h>

using namespace std;

struct Node {
    int value;
    vector<Node*> children;
};

void dfs(Node* node) {
    if (node == nullptr) return;
    cout << node->value << " ";
    #pragma omp parallel for
    for (size_t i = 0; i < node->children.size(); ++i) {
        dfs(node->children[i]);
    }
}

int main() {
    Node* root = new Node{1};
    stack<Node*> nodes;
    nodes.push(root);
    char choice;

    do {
        cout << "Enter data for the next node: ";
        int data;
        cin >> data;
        Node* newNode = new Node{data};
        Node* current = nodes.top();
        current->children.push_back(newNode);
        nodes.push(newNode);
        cout << "Do you want to insert one more node? (y/n): ";
        cin >> choice;
    } while (choice == 'y' || choice == 'Y');

    cout << "DFS traversal result: ";
    dfs(root);
    cout << endl;

    // Clean up memory
    // You may want to implement a function to delete the nodes in a similar fashion to DFS

    return 0;
}

Output-
4
y
22
y
7
y
10
n